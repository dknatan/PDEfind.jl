var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = PDEfind","category":"page"},{"location":"#PDEfind","page":"Home","title":"PDEfind","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for PDEfind.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [PDEfind]","category":"page"},{"location":"#PDEfind.PolynomialBasis","page":"Home","title":"PDEfind.PolynomialBasis","text":"PolynomialBasis <: AbstractBasis\n\nBasis of polynomial functions up to degree max_degree of n_variables variables.\n\nInitialization\n\nPolynomialBasis(\n    max_degree::Int,\n    n_variables::Int\n)\n\nwith ... \n\nFields\n\nmax_degree::Int\nn_variables::Int\npoly_vectors::Array\npoly_functions::Array{Function}\n\nUsage\n\nTODO\n\n\n\n\n\n","category":"type"},{"location":"#PDEfind.TimeDerivative","page":"Home","title":"PDEfind.TimeDerivative","text":"TimeDerivative{T}\n\nFinite difference operator for time derivative on a grid. \n\nInitialization\n\nTimeDerivative(\n    g::TimeSpaceGrid1D; \n    order::Int = 2,\n)\n\nwith order being the order of approximation of the finite difference method. \n\nFields\n\nM::T\n\n\n\n\n\n","category":"type"},{"location":"#PDEfind.TimeSpaceGrid1D","page":"Home","title":"PDEfind.TimeSpaceGrid1D","text":"TimeSpaceGrid1D{T}\n\nDicretization grid for time + 1D space finite difference schemes. \n\nInitialization\n\nTimeSpaceGrid1D(time_array, space_array)\n\nwith both assumed to have constant spacing \n\nFields\n\nt::AbstractArray{T}\nx::AbstractArray{T}\ndt::T\ndx::T\nnt::Int\nnx::Int\nN::Int\nt_grid::AbstractMatrix{T}\nx_grid::AbstractMatrix{T}\n\n\n\n\n\n","category":"type"},{"location":"#PDEfind.XDerivative","page":"Home","title":"PDEfind.XDerivative","text":"XDerivative{T}\n\nFinite difference operator for (1st) spatial derivative on a grid. \n\nInitialization\n\nXDerivative(\n    g::TimeSpaceGrid1D; \n    order::Int = 2,\n    boundary_condition::String = \"neumann\"\n)\n\nwith order being the order of approximation of the finite difference method and boundary_condition either \"periodic\" or \"neumann\" (no periodicity).\n\nFields\n\nM::T\n\n\n\n\n\n","category":"type"},{"location":"#PDEfind.GetVariablesMatrix-Tuple{Int64, Matrix, TimeSpaceGrid1D, XDerivative}","page":"Home","title":"PDEfind.GetVariablesMatrix","text":"GetVariablesMatrix(\n    max_derivatives::Int,\n    data_array::Matrix,\n    g::TimeSpaceGrid1D,\n    ∂x::XDerivative\n\n)   \n\nCreate a matrix (nt*nx, max_derivatives+1) containing all j-derivatives evaluated at all time-space coordinates i. Note: This is NOT the Θ matrix. \n\n\n\n\n\n","category":"method"},{"location":"#PDEfind.STRidge_cascade-Tuple{Matrix{Float64}, Vector{Float64}, Any}","page":"Home","title":"PDEfind.STRidge_cascade","text":"STRidge_cascade(\n    theta::Matrix{Float64}, \n    dt_data_array_flat::Vector{Float64}, \n    MyBasis::PolynomialBasis; \n    λ::Float64 = 0.0, \n    tol::Float64 = 0.01, \n    iters::Int64 = 1,\n    verbose = false\n)    \nConduct sequential thresholded ridge regression. See algorithm 1 in Rudy et al.\nReturns optimal ξ.\n\n\n\n\n\n","category":"method"},{"location":"#PDEfind.TrainSTRidge-Tuple{Matrix{Float64}, Vector{Float64}, Any}","page":"Home","title":"PDEfind.TrainSTRidge","text":"TrainSTRidge(\n    theta::Matrix{Float64}, \n    dt_data_array_flat::Vector{Float64}, \n    poly_vectors; \n    λ::Float64 = 1e-4, \n    tol_multiplier::Float64 = 1e2,\n    iters::Int64 = 1,\n    verbose::Bool = true,\n    cond_number_multiplier::Float64 = 1e-2,\n    max_tol_iters::Int64 = 100\n)\nConduct sequential thresholded ridge regression. See algorithm 2 in Rudy et al and the .pdf file attached by the author.\nReturns optimal ξ.\n\n\n\n\n\n","category":"method"},{"location":"#PDEfind.all_polynomial_functions-Tuple{Int64, Int64}","page":"Home","title":"PDEfind.all_polynomial_functions","text":"all_polynomial_functions(max_degree::Int, n_variables::Int)\n\nConstruct all polynomials up to degree max_degree of n_variables variables.  Returns array of functions of n_variables variables. Only works for 5 variables or less.\n\n\n\n\n\n","category":"method"},{"location":"#PDEfind.all_polynomial_vectors-Tuple{Int64, Int64}","page":"Home","title":"PDEfind.all_polynomial_vectors","text":"all_polynomial_vectors(max_degree::Int, n_variables::Int)\n\nConstruct all polynomials up to degree max_degree of n_variables variables.  Returns array of arrays of length n_variables, i-th entry representing the power of i-th variable. \n\n\n\n\n\n","category":"method"},{"location":"#PDEfind.evaluate-Tuple{PolynomialBasis, Any}","page":"Home","title":"PDEfind.evaluate","text":"function evaluate(basis::PolynomialBasis, variables_array)\n\nEvaluate basis functions at different values of variables. If basis includes M functions (of n variables) and the variables_array is an N × n array, the output is a N × M array.\n\n\n\n\n\n","category":"method"},{"location":"#PDEfind.lambda_sweep-Tuple{Any, Matrix{Float64}, Vector{Float64}, Any}","page":"Home","title":"PDEfind.lambda_sweep","text":"function lambda_sweep(\n    lambda_range,\n    Θ::Matrix{Float64}, \n    dt_data_array_flat::Vector{Float64},\n    poly_vectors;\n    iters::Int64 = 1,\n    cond_number_multiplier::Float64 = 1e-6\n)\n\nEvaluate optimal ξ at all values of `lambda_range`. Returns array of size `(length(poly_vectors), 2)` with optimal (λ, ξ_i) values for each possible polynomial.\n\n\n\n\n\n","category":"method"},{"location":"#PDEfind.polynomial_vectors-Tuple{Int64, Int64}","page":"Home","title":"PDEfind.polynomial_vectors","text":"polynomial_vectors(degree::Int, n_variables::Int)\n\nConstruct all polynomials of degree exactly degree of n_variables variables. Returns array of arrays of length n_variables, i-th entry representing the power of i-th variable. \n\n\n\n\n\n","category":"method"}]
}
